{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;\n\nconst _ = require(\"lodash\");\n\nconst function_configuration_1 = require(\"./function-configuration\");\n\nconst logger_1 = require(\"./logger\");\n/** @hidden */\n\n\nconst WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\n\nclass Change {\n  constructor(before, after) {\n    this.before = before;\n    this.after = after;\n  }\n\n}\n\nexports.Change = Change;\n\n(function (Change) {\n  /** @hidden */\n  function reinterpretCast(x) {\n    return x;\n  }\n  /**\n   * @hidden\n   * Factory method for creating a Change from a `before` object and an `after`\n   * object.\n   */\n\n\n  function fromObjects(before, after) {\n    return new Change(before, after);\n  }\n\n  Change.fromObjects = fromObjects;\n  /**\n   * @hidden\n   * Factory method for creating a Change from a JSON and an optional customizer\n   * function to be applied to both the `before` and the `after` fields.\n   */\n\n  function fromJSON(json) {\n    let customizer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : reinterpretCast;\n    let before = { ...json.before\n    };\n\n    if (json.fieldMask) {\n      before = applyFieldMask(before, json.after, json.fieldMask);\n    }\n\n    return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n  }\n\n  Change.fromJSON = fromJSON;\n  /** @hidden */\n\n  function applyFieldMask(sparseBefore, after, fieldMask) {\n    const before = { ...after\n    };\n    const masks = fieldMask.split(',');\n    masks.forEach(mask => {\n      const val = _.get(sparseBefore, mask);\n\n      if (typeof val === 'undefined') {\n        _.unset(before, mask);\n      } else {\n        _.set(before, mask, val);\n      }\n    });\n    return before;\n  }\n\n  Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\n\n\nfunction makeCloudFunction(_ref) {\n  let {\n    after = () => {},\n    before = () => {},\n    contextOnlyHandler,\n    dataConstructor = raw => raw.data,\n    eventType,\n    handler,\n    labels = {},\n    legacyEventType,\n    options = {},\n    provider,\n    service,\n    triggerResource\n  } = _ref;\n\n  const cloudFunction = (data, context) => {\n    if (legacyEventType && context.eventType === legacyEventType) {\n      /*\n       * v1beta1 event flow has different format for context, transform them to\n       * new format.\n       */\n      context.eventType = provider + '.' + eventType;\n      context.resource = {\n        service,\n        name: context.resource\n      };\n    }\n\n    const event = {\n      data,\n      context\n    };\n\n    if (provider === 'google.firebase.database') {\n      context.authType = _detectAuthType(event);\n\n      if (context.authType !== 'ADMIN') {\n        context.auth = _makeAuth(event, context.authType);\n      } else {\n        delete context.auth;\n      }\n    }\n\n    if (triggerResource() == null) {\n      Object.defineProperty(context, 'params', {\n        get: () => {\n          throw new Error('context.params is not available when using the handler namespace.');\n        }\n      });\n    } else {\n      context.params = context.params || _makeParams(context, triggerResource);\n    }\n\n    before(event);\n    let promise;\n\n    if (labels && labels['deployment-scheduled']) {\n      // Scheduled function do not have meaningful data, so exclude it\n      promise = contextOnlyHandler(context);\n    } else {\n      const dataOrChange = dataConstructor(event);\n      promise = handler(dataOrChange, context);\n    }\n\n    if (typeof promise === 'undefined') {\n      logger_1.warn('Function returned undefined, expected Promise or value');\n    }\n\n    return Promise.resolve(promise).then(result => {\n      after(event);\n      return result;\n    }).catch(err => {\n      after(event);\n      return Promise.reject(err);\n    });\n  };\n\n  Object.defineProperty(cloudFunction, '__trigger', {\n    get: () => {\n      if (triggerResource() == null) {\n        return {};\n      }\n\n      const trigger = _.assign(optionsToTrigger(options), {\n        eventTrigger: {\n          resource: triggerResource(),\n          eventType: legacyEventType || provider + '.' + eventType,\n          service\n        }\n      });\n\n      if (!_.isEmpty(labels)) {\n        trigger.labels = labels;\n      }\n\n      return trigger;\n    }\n  });\n  cloudFunction.run = handler || contextOnlyHandler;\n  return cloudFunction;\n}\n\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\n\nfunction _makeParams(context, triggerResourceGetter) {\n  if (context.params) {\n    // In unit testing, user may directly provide `context.params`.\n    return context.params;\n  }\n\n  if (!context.resource) {\n    // In unit testing, `resource` may be unpopulated for a test event.\n    return {};\n  }\n\n  const triggerResource = triggerResourceGetter();\n  const wildcards = triggerResource.match(WILDCARD_REGEX);\n  const params = {};\n\n  if (wildcards) {\n    const triggerResourceParts = _.split(triggerResource, '/');\n\n    const eventResourceParts = _.split(context.resource.name, '/');\n\n    _.forEach(wildcards, wildcard => {\n      const wildcardNoBraces = wildcard.slice(1, -1);\n\n      const position = _.indexOf(triggerResourceParts, wildcard);\n\n      params[wildcardNoBraces] = eventResourceParts[position];\n    });\n  }\n\n  return params;\n}\n/** @hidden */\n\n\nfunction _makeAuth(event, authType) {\n  if (authType === 'UNAUTHENTICATED') {\n    return null;\n  }\n\n  return {\n    uid: _.get(event, 'context.auth.variable.uid'),\n    token: _.get(event, 'context.auth.variable.token')\n  };\n}\n/** @hidden */\n\n\nfunction _detectAuthType(event) {\n  if (_.get(event, 'context.auth.admin')) {\n    return 'ADMIN';\n  }\n\n  if (_.has(event, 'context.auth.variable')) {\n    return 'USER';\n  }\n\n  return 'UNAUTHENTICATED';\n}\n/** @hidden */\n\n\nfunction optionsToTrigger(options) {\n  const trigger = {};\n\n  if (options.regions) {\n    trigger.regions = options.regions;\n  }\n\n  if (options.failurePolicy !== undefined) {\n    switch (options.failurePolicy) {\n      case false:\n        trigger.failurePolicy = undefined;\n        break;\n\n      case true:\n        trigger.failurePolicy = function_configuration_1.DEFAULT_FAILURE_POLICY;\n        break;\n\n      default:\n        trigger.failurePolicy = options.failurePolicy;\n    }\n  }\n\n  if (options.timeoutSeconds) {\n    trigger.timeout = options.timeoutSeconds.toString() + 's';\n  }\n\n  if (options.memory) {\n    const memoryLookup = {\n      '128MB': 128,\n      '256MB': 256,\n      '512MB': 512,\n      '1GB': 1024,\n      '2GB': 2048,\n      '4GB': 4096,\n      '8GB': 8192\n    };\n    trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n  }\n\n  if (options.schedule) {\n    trigger.schedule = options.schedule;\n  }\n\n  if (options.minInstances) {\n    trigger.minInstances = options.minInstances;\n  }\n\n  if (options.maxInstances) {\n    trigger.maxInstances = options.maxInstances;\n  }\n\n  if (options.ingressSettings) {\n    trigger.ingressSettings = options.ingressSettings;\n  }\n\n  if (options.vpcConnector) {\n    trigger.vpcConnector = options.vpcConnector;\n  }\n\n  if (options.vpcConnectorEgressSettings) {\n    trigger.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;\n  }\n\n  if (options.serviceAccount) {\n    if (options.serviceAccount === 'default') {// Do nothing, since this is equivalent to not setting serviceAccount.\n    } else if (options.serviceAccount.endsWith('@')) {\n      if (!process.env.GCLOUD_PROJECT) {\n        throw new Error(`Unable to determine email for service account '${options.serviceAccount}' because process.env.GCLOUD_PROJECT is not set.`);\n      }\n\n      trigger.serviceAccountEmail = `${options.serviceAccount}${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`;\n    } else if (options.serviceAccount.includes('@')) {\n      trigger.serviceAccountEmail = options.serviceAccount;\n    } else {\n      throw new Error(`Invalid option for serviceAccount: '${options.serviceAccount}'. Valid options are 'default', a service account email, or '{serviceAccountName}@'`);\n    }\n  }\n\n  return trigger;\n}\n\nexports.optionsToTrigger = optionsToTrigger;","map":{"version":3,"sources":["/Users/phuc/node_modules/firebase-functions/lib/cloud-functions.js"],"names":["Object","defineProperty","exports","value","optionsToTrigger","makeCloudFunction","Change","_","require","function_configuration_1","logger_1","WILDCARD_REGEX","RegExp","constructor","before","after","reinterpretCast","x","fromObjects","fromJSON","json","customizer","fieldMask","applyFieldMask","sparseBefore","masks","split","forEach","mask","val","get","unset","set","contextOnlyHandler","dataConstructor","raw","data","eventType","handler","labels","legacyEventType","options","provider","service","triggerResource","cloudFunction","context","resource","name","event","authType","_detectAuthType","auth","_makeAuth","Error","params","_makeParams","promise","dataOrChange","warn","Promise","resolve","then","result","catch","err","reject","trigger","assign","eventTrigger","isEmpty","run","triggerResourceGetter","wildcards","match","triggerResourceParts","eventResourceParts","wildcard","wildcardNoBraces","slice","position","indexOf","uid","token","has","regions","failurePolicy","undefined","DEFAULT_FAILURE_POLICY","timeoutSeconds","timeout","toString","memory","memoryLookup","availableMemoryMb","schedule","minInstances","maxInstances","ingressSettings","vpcConnector","vpcConnectorEgressSettings","serviceAccount","endsWith","process","env","GCLOUD_PROJECT","serviceAccountEmail","includes"],"mappings":"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","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;\nconst _ = require(\"lodash\");\nconst function_configuration_1 = require(\"./function-configuration\");\nconst logger_1 = require(\"./logger\");\n/** @hidden */\nconst WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\nclass Change {\n    constructor(before, after) {\n        this.before = before;\n        this.after = after;\n    }\n}\nexports.Change = Change;\n(function (Change) {\n    /** @hidden */\n    function reinterpretCast(x) {\n        return x;\n    }\n    /**\n     * @hidden\n     * Factory method for creating a Change from a `before` object and an `after`\n     * object.\n     */\n    function fromObjects(before, after) {\n        return new Change(before, after);\n    }\n    Change.fromObjects = fromObjects;\n    /**\n     * @hidden\n     * Factory method for creating a Change from a JSON and an optional customizer\n     * function to be applied to both the `before` and the `after` fields.\n     */\n    function fromJSON(json, customizer = reinterpretCast) {\n        let before = { ...json.before };\n        if (json.fieldMask) {\n            before = applyFieldMask(before, json.after, json.fieldMask);\n        }\n        return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n    }\n    Change.fromJSON = fromJSON;\n    /** @hidden */\n    function applyFieldMask(sparseBefore, after, fieldMask) {\n        const before = { ...after };\n        const masks = fieldMask.split(',');\n        masks.forEach((mask) => {\n            const val = _.get(sparseBefore, mask);\n            if (typeof val === 'undefined') {\n                _.unset(before, mask);\n            }\n            else {\n                _.set(before, mask, val);\n            }\n        });\n        return before;\n    }\n    Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\nfunction makeCloudFunction({ after = () => { }, before = () => { }, contextOnlyHandler, dataConstructor = (raw) => raw.data, eventType, handler, labels = {}, legacyEventType, options = {}, provider, service, triggerResource, }) {\n    const cloudFunction = (data, context) => {\n        if (legacyEventType && context.eventType === legacyEventType) {\n            /*\n             * v1beta1 event flow has different format for context, transform them to\n             * new format.\n             */\n            context.eventType = provider + '.' + eventType;\n            context.resource = {\n                service,\n                name: context.resource,\n            };\n        }\n        const event = {\n            data,\n            context,\n        };\n        if (provider === 'google.firebase.database') {\n            context.authType = _detectAuthType(event);\n            if (context.authType !== 'ADMIN') {\n                context.auth = _makeAuth(event, context.authType);\n            }\n            else {\n                delete context.auth;\n            }\n        }\n        if (triggerResource() == null) {\n            Object.defineProperty(context, 'params', {\n                get: () => {\n                    throw new Error('context.params is not available when using the handler namespace.');\n                },\n            });\n        }\n        else {\n            context.params = context.params || _makeParams(context, triggerResource);\n        }\n        before(event);\n        let promise;\n        if (labels && labels['deployment-scheduled']) {\n            // Scheduled function do not have meaningful data, so exclude it\n            promise = contextOnlyHandler(context);\n        }\n        else {\n            const dataOrChange = dataConstructor(event);\n            promise = handler(dataOrChange, context);\n        }\n        if (typeof promise === 'undefined') {\n            logger_1.warn('Function returned undefined, expected Promise or value');\n        }\n        return Promise.resolve(promise)\n            .then((result) => {\n            after(event);\n            return result;\n        })\n            .catch((err) => {\n            after(event);\n            return Promise.reject(err);\n        });\n    };\n    Object.defineProperty(cloudFunction, '__trigger', {\n        get: () => {\n            if (triggerResource() == null) {\n                return {};\n            }\n            const trigger = _.assign(optionsToTrigger(options), {\n                eventTrigger: {\n                    resource: triggerResource(),\n                    eventType: legacyEventType || provider + '.' + eventType,\n                    service,\n                },\n            });\n            if (!_.isEmpty(labels)) {\n                trigger.labels = labels;\n            }\n            return trigger;\n        },\n    });\n    cloudFunction.run = handler || contextOnlyHandler;\n    return cloudFunction;\n}\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\nfunction _makeParams(context, triggerResourceGetter) {\n    if (context.params) {\n        // In unit testing, user may directly provide `context.params`.\n        return context.params;\n    }\n    if (!context.resource) {\n        // In unit testing, `resource` may be unpopulated for a test event.\n        return {};\n    }\n    const triggerResource = triggerResourceGetter();\n    const wildcards = triggerResource.match(WILDCARD_REGEX);\n    const params = {};\n    if (wildcards) {\n        const triggerResourceParts = _.split(triggerResource, '/');\n        const eventResourceParts = _.split(context.resource.name, '/');\n        _.forEach(wildcards, (wildcard) => {\n            const wildcardNoBraces = wildcard.slice(1, -1);\n            const position = _.indexOf(triggerResourceParts, wildcard);\n            params[wildcardNoBraces] = eventResourceParts[position];\n        });\n    }\n    return params;\n}\n/** @hidden */\nfunction _makeAuth(event, authType) {\n    if (authType === 'UNAUTHENTICATED') {\n        return null;\n    }\n    return {\n        uid: _.get(event, 'context.auth.variable.uid'),\n        token: _.get(event, 'context.auth.variable.token'),\n    };\n}\n/** @hidden */\nfunction _detectAuthType(event) {\n    if (_.get(event, 'context.auth.admin')) {\n        return 'ADMIN';\n    }\n    if (_.has(event, 'context.auth.variable')) {\n        return 'USER';\n    }\n    return 'UNAUTHENTICATED';\n}\n/** @hidden */\nfunction optionsToTrigger(options) {\n    const trigger = {};\n    if (options.regions) {\n        trigger.regions = options.regions;\n    }\n    if (options.failurePolicy !== undefined) {\n        switch (options.failurePolicy) {\n            case false:\n                trigger.failurePolicy = undefined;\n                break;\n            case true:\n                trigger.failurePolicy = function_configuration_1.DEFAULT_FAILURE_POLICY;\n                break;\n            default:\n                trigger.failurePolicy = options.failurePolicy;\n        }\n    }\n    if (options.timeoutSeconds) {\n        trigger.timeout = options.timeoutSeconds.toString() + 's';\n    }\n    if (options.memory) {\n        const memoryLookup = {\n            '128MB': 128,\n            '256MB': 256,\n            '512MB': 512,\n            '1GB': 1024,\n            '2GB': 2048,\n            '4GB': 4096,\n            '8GB': 8192,\n        };\n        trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n    }\n    if (options.schedule) {\n        trigger.schedule = options.schedule;\n    }\n    if (options.minInstances) {\n        trigger.minInstances = options.minInstances;\n    }\n    if (options.maxInstances) {\n        trigger.maxInstances = options.maxInstances;\n    }\n    if (options.ingressSettings) {\n        trigger.ingressSettings = options.ingressSettings;\n    }\n    if (options.vpcConnector) {\n        trigger.vpcConnector = options.vpcConnector;\n    }\n    if (options.vpcConnectorEgressSettings) {\n        trigger.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;\n    }\n    if (options.serviceAccount) {\n        if (options.serviceAccount === 'default') {\n            // Do nothing, since this is equivalent to not setting serviceAccount.\n        }\n        else if (options.serviceAccount.endsWith('@')) {\n            if (!process.env.GCLOUD_PROJECT) {\n                throw new Error(`Unable to determine email for service account '${options.serviceAccount}' because process.env.GCLOUD_PROJECT is not set.`);\n            }\n            trigger.serviceAccountEmail = `${options.serviceAccount}${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`;\n        }\n        else if (options.serviceAccount.includes('@')) {\n            trigger.serviceAccountEmail = options.serviceAccount;\n        }\n        else {\n            throw new Error(`Invalid option for serviceAccount: '${options.serviceAccount}'. Valid options are 'default', a service account email, or '{serviceAccountName}@'`);\n        }\n    }\n    return trigger;\n}\nexports.optionsToTrigger = optionsToTrigger;\n"]},"metadata":{},"sourceType":"script"}