{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._onCallWithOptions = exports.decode = exports.encode = exports.HttpsError = exports._onRequestWithOptions = exports.onCall = exports.onRequest = void 0;\n\nconst cors = require(\"cors\");\n\nconst _ = require(\"lodash\");\n\nconst apps_1 = require(\"../apps\");\n\nconst cloud_functions_1 = require(\"../cloud-functions\");\n\nconst logger_1 = require(\"../logger\");\n/**\n * Handle HTTP requests.\n * @param handler A function that takes a request and response object,\n * same signature as an Express app.\n */\n\n\nfunction onRequest(handler) {\n  return _onRequestWithOptions(handler, {});\n}\n\nexports.onRequest = onRequest;\n/**\n * Declares a callable method for clients to call using a Firebase SDK.\n * @param handler A method that takes a data and context and returns a value.\n */\n\nfunction onCall(handler) {\n  return _onCallWithOptions(handler, {});\n}\n\nexports.onCall = onCall;\n/** @hidden */\n\nfunction _onRequestWithOptions(handler, options) {\n  // lets us add __trigger without altering handler:\n  const cloudFunction = (req, res) => {\n    return handler(req, res);\n  };\n\n  cloudFunction.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n    httpsTrigger: {}\n  }); // TODO parse the options\n\n  return cloudFunction;\n}\n\nexports._onRequestWithOptions = _onRequestWithOptions;\n/**\n * Standard error codes and HTTP statuses for different ways a request can fail,\n * as defined by:\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n *\n * This map is used primarily to convert from a client error code string to\n * to the HTTP format error code string and status, and make sure it's in the\n * supported set.\n */\n\nconst errorCodeMap = {\n  ok: {\n    canonicalName: 'OK',\n    status: 200\n  },\n  cancelled: {\n    canonicalName: 'CANCELLED',\n    status: 499\n  },\n  unknown: {\n    canonicalName: 'UNKNOWN',\n    status: 500\n  },\n  'invalid-argument': {\n    canonicalName: 'INVALID_ARGUMENT',\n    status: 400\n  },\n  'deadline-exceeded': {\n    canonicalName: 'DEADLINE_EXCEEDED',\n    status: 504\n  },\n  'not-found': {\n    canonicalName: 'NOT_FOUND',\n    status: 404\n  },\n  'already-exists': {\n    canonicalName: 'ALREADY_EXISTS',\n    status: 409\n  },\n  'permission-denied': {\n    canonicalName: 'PERMISSION_DENIED',\n    status: 403\n  },\n  unauthenticated: {\n    canonicalName: 'UNAUTHENTICATED',\n    status: 401\n  },\n  'resource-exhausted': {\n    canonicalName: 'RESOURCE_EXHAUSTED',\n    status: 429\n  },\n  'failed-precondition': {\n    canonicalName: 'FAILED_PRECONDITION',\n    status: 400\n  },\n  aborted: {\n    canonicalName: 'ABORTED',\n    status: 409\n  },\n  'out-of-range': {\n    canonicalName: 'OUT_OF_RANGE',\n    status: 400\n  },\n  unimplemented: {\n    canonicalName: 'UNIMPLEMENTED',\n    status: 501\n  },\n  internal: {\n    canonicalName: 'INTERNAL',\n    status: 500\n  },\n  unavailable: {\n    canonicalName: 'UNAVAILABLE',\n    status: 503\n  },\n  'data-loss': {\n    canonicalName: 'DATA_LOSS',\n    status: 500\n  }\n};\n/**\n * An explicit error that can be thrown from a handler to send an error to the\n * client that called the function.\n */\n\nclass HttpsError extends Error {\n  constructor(code, message, details) {\n    super(message); // A sanity check for non-TypeScript consumers.\n\n    if (code in errorCodeMap === false) {\n      throw new Error(`Unknown error code: ${code}.`);\n    }\n\n    this.code = code;\n    this.details = details;\n    this.httpErrorCode = errorCodeMap[code];\n  }\n  /** @hidden */\n\n\n  toJSON() {\n    const {\n      details,\n      httpErrorCode: {\n        canonicalName: status\n      },\n      message\n    } = this;\n    return { ...(details === undefined ? {} : {\n        details\n      }),\n      message,\n      status\n    };\n  }\n\n}\n\nexports.HttpsError = HttpsError;\n/** @hidden */\n// Returns true if req is a properly formatted callable request.\n\nfunction isValidRequest(req) {\n  // The body must not be empty.\n  if (!req.body) {\n    logger_1.warn('Request is missing body.');\n    return false;\n  } // Make sure it's a POST.\n\n\n  if (req.method !== 'POST') {\n    logger_1.warn('Request has invalid method.', req.method);\n    return false;\n  } // Check that the Content-Type is JSON.\n\n\n  let contentType = (req.header('Content-Type') || '').toLowerCase(); // If it has a charset, just ignore it for now.\n\n  const semiColon = contentType.indexOf(';');\n\n  if (semiColon >= 0) {\n    contentType = contentType.substr(0, semiColon).trim();\n  }\n\n  if (contentType !== 'application/json') {\n    logger_1.warn('Request has incorrect Content-Type.', contentType);\n    return false;\n  } // The body must have data.\n\n\n  if (_.isUndefined(req.body.data)) {\n    logger_1.warn('Request body is missing data.', req.body);\n    return false;\n  } // TODO(klimt): Allow only whitelisted http headers.\n  // Verify that the body does not have any extra fields.\n\n\n  const extras = _.omit(req.body, 'data');\n\n  if (!_.isEmpty(extras)) {\n    logger_1.warn('Request body has extra fields.', extras);\n    return false;\n  }\n\n  return true;\n}\n/** @hidden */\n\n\nconst LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\n/** @hidden */\n\nconst UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\n/**\n * Encodes arbitrary data in our special format for JSON.\n * This is exposed only for testing.\n */\n\n/** @hidden */\n\nfunction encode(data) {\n  if (_.isNull(data) || _.isUndefined(data)) {\n    return null;\n  } // Oddly, _.isFinite(new Number(x)) always returns false, so unwrap Numbers.\n\n\n  if (data instanceof Number) {\n    data = data.valueOf();\n  }\n\n  if (_.isFinite(data)) {\n    // Any number in JS is safe to put directly in JSON and parse as a double\n    // without any loss of precision.\n    return data;\n  }\n\n  if (_.isBoolean(data)) {\n    return data;\n  }\n\n  if (_.isString(data)) {\n    return data;\n  }\n\n  if (_.isArray(data)) {\n    return _.map(data, encode);\n  }\n\n  if (_.isObject(data)) {\n    // It's not safe to use _.forEach, because the object might be 'array-like'\n    // if it has a key called 'length'. Note that this intentionally overrides\n    // any toJSON method that an object may have.\n    return _.mapValues(data, encode);\n  } // If we got this far, the data is not encodable.\n\n\n  logger_1.error('Data cannot be encoded in JSON.', data);\n  throw new Error('Data cannot be encoded in JSON: ' + data);\n}\n\nexports.encode = encode;\n/**\n * Decodes our special format for JSON into native types.\n * This is exposed only for testing.\n */\n\n/** @hidden */\n\nfunction decode(data) {\n  if (data === null) {\n    return data;\n  }\n\n  if (data['@type']) {\n    switch (data['@type']) {\n      case LONG_TYPE: // Fall through and handle this the same as unsigned.\n\n      case UNSIGNED_LONG_TYPE:\n        {\n          // Technically, this could work return a valid number for malformed\n          // data if there was a number followed by garbage. But it's just not\n          // worth all the extra code to detect that case.\n          const value = parseFloat(data.value);\n\n          if (_.isNaN(value)) {\n            logger_1.error('Data cannot be decoded from JSON.', data);\n            throw new Error('Data cannot be decoded from JSON: ' + data);\n          }\n\n          return value;\n        }\n\n      default:\n        {\n          logger_1.error('Data cannot be decoded from JSON.', data);\n          throw new Error('Data cannot be decoded from JSON: ' + data);\n        }\n    }\n  }\n\n  if (_.isArray(data)) {\n    return _.map(data, decode);\n  }\n\n  if (_.isObject(data)) {\n    // It's not safe to use _.forEach, because the object might be 'array-like'\n    // if it has a key called 'length'.\n    return _.mapValues(data, decode);\n  } // Anything else is safe to return.\n\n\n  return data;\n}\n\nexports.decode = decode;\n/**\n * Check and verify tokens included in the requests. Once verified, tokens\n * are injected into the callable context.\n *\n * @param {Request} req - Request sent to the Callable function.\n * @param {CallableContext} ctx - Context to be sent to callable function handler.\n * @return {CallableTokenStatus} Status of the token verifications.\n */\n\n/** @hidden */\n\nasync function checkTokens(req, ctx) {\n  const verifications = {\n    app: 'MISSING',\n    auth: 'MISSING'\n  };\n  const appCheck = req.header('X-Firebase-AppCheck');\n\n  if (appCheck) {\n    verifications.app = 'INVALID';\n\n    try {\n      if (!apps_1.apps().admin.appCheck) {\n        throw new Error('Cannot validate AppCheck token. Please update Firebase Admin SDK to >= v9.8.0');\n      }\n\n      const appCheckToken = await apps_1.apps().admin.appCheck().verifyToken(appCheck);\n      ctx.app = {\n        appId: appCheckToken.appId,\n        token: appCheckToken.token\n      };\n      verifications.app = 'VALID';\n    } catch (err) {\n      logger_1.warn('Failed to validate AppCheck token.', err);\n    }\n  }\n\n  const authorization = req.header('Authorization');\n\n  if (authorization) {\n    verifications.auth = 'INVALID';\n    const match = authorization.match(/^Bearer (.*)$/);\n\n    if (match) {\n      const idToken = match[1];\n\n      try {\n        const authToken = await apps_1.apps().admin.auth().verifyIdToken(idToken);\n        verifications.auth = 'VALID';\n        ctx.auth = {\n          uid: authToken.uid,\n          token: authToken\n        };\n      } catch (err) {\n        logger_1.warn('Failed to validate auth token.', err);\n      }\n    }\n  }\n\n  const logPayload = {\n    verifications,\n    'logging.googleapis.com/labels': {\n      'firebase-log-type': 'callable-request-verification'\n    }\n  };\n  const errs = [];\n\n  if (verifications.app === 'INVALID') {\n    errs.push('AppCheck token was rejected.');\n  }\n\n  if (verifications.auth === 'INVALID') {\n    errs.push('Auth token was rejected.');\n  }\n\n  if (errs.length == 0) {\n    logger_1.info('Callable request verification passed', logPayload);\n  } else {\n    logger_1.warn(`Callable request verification failed: ${errs.join(' ')}`, logPayload);\n  }\n\n  return verifications;\n}\n/** @hidden */\n\n\nconst corsHandler = cors({\n  origin: true,\n  methods: 'POST'\n});\n/** @hidden */\n\nfunction _onCallWithOptions(handler, options) {\n  const func = async (req, res) => {\n    try {\n      if (!isValidRequest(req)) {\n        logger_1.error('Invalid request, unable to process.');\n        throw new HttpsError('invalid-argument', 'Bad Request');\n      }\n\n      const context = {\n        rawRequest: req\n      };\n      const tokenStatus = await checkTokens(req, context);\n\n      if (tokenStatus.app === 'INVALID' || tokenStatus.auth === 'INVALID') {\n        throw new HttpsError('unauthenticated', 'Unauthenticated');\n      }\n\n      const instanceId = req.header('Firebase-Instance-ID-Token');\n\n      if (instanceId) {\n        // Validating the token requires an http request, so we don't do it.\n        // If the user wants to use it for something, it will be validated then.\n        // Currently, the only real use case for this token is for sending\n        // pushes with FCM. In that case, the FCM APIs will validate the token.\n        context.instanceIdToken = req.header('Firebase-Instance-ID-Token');\n      }\n\n      const data = decode(req.body.data);\n      let result = await handler(data, context); // Encode the result as JSON to preserve types like Dates.\n\n      result = encode(result); // If there was some result, encode it in the body.\n\n      const responseBody = {\n        result\n      };\n      res.status(200).send(responseBody);\n    } catch (err) {\n      if (!(err instanceof HttpsError)) {\n        // This doesn't count as an 'explicit' error.\n        logger_1.error('Unhandled error', err);\n        err = new HttpsError('internal', 'INTERNAL');\n      }\n\n      const {\n        status\n      } = err.httpErrorCode;\n      const body = {\n        error: err.toJSON()\n      };\n      res.status(status).send(body);\n    }\n  }; // Wrap the function with a cors handler.\n\n\n  const corsFunc = (req, res) => {\n    return corsHandler(req, res, () => func(req, res));\n  };\n\n  corsFunc.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n    httpsTrigger: {},\n    labels: {\n      'deployment-callable': 'true'\n    }\n  });\n  corsFunc.run = handler;\n  return corsFunc;\n}\n\nexports._onCallWithOptions = _onCallWithOptions;","map":{"version":3,"sources":["/Users/phuc/node_modules/firebase-functions/lib/providers/https.js"],"names":["Object","defineProperty","exports","value","_onCallWithOptions","decode","encode","HttpsError","_onRequestWithOptions","onCall","onRequest","cors","require","_","apps_1","cloud_functions_1","logger_1","handler","options","cloudFunction","req","res","__trigger","assign","optionsToTrigger","httpsTrigger","errorCodeMap","ok","canonicalName","status","cancelled","unknown","unauthenticated","aborted","unimplemented","internal","unavailable","Error","constructor","code","message","details","httpErrorCode","toJSON","undefined","isValidRequest","body","warn","method","contentType","header","toLowerCase","semiColon","indexOf","substr","trim","isUndefined","data","extras","omit","isEmpty","LONG_TYPE","UNSIGNED_LONG_TYPE","isNull","Number","valueOf","isFinite","isBoolean","isString","isArray","map","isObject","mapValues","error","parseFloat","isNaN","checkTokens","ctx","verifications","app","auth","appCheck","apps","admin","appCheckToken","verifyToken","appId","token","err","authorization","match","idToken","authToken","verifyIdToken","uid","logPayload","errs","push","length","info","join","corsHandler","origin","methods","func","context","rawRequest","tokenStatus","instanceId","instanceIdToken","result","responseBody","send","corsFunc","labels","run"],"mappings":"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","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._onCallWithOptions = exports.decode = exports.encode = exports.HttpsError = exports._onRequestWithOptions = exports.onCall = exports.onRequest = void 0;\nconst cors = require(\"cors\");\nconst _ = require(\"lodash\");\nconst apps_1 = require(\"../apps\");\nconst cloud_functions_1 = require(\"../cloud-functions\");\nconst logger_1 = require(\"../logger\");\n/**\n * Handle HTTP requests.\n * @param handler A function that takes a request and response object,\n * same signature as an Express app.\n */\nfunction onRequest(handler) {\n    return _onRequestWithOptions(handler, {});\n}\nexports.onRequest = onRequest;\n/**\n * Declares a callable method for clients to call using a Firebase SDK.\n * @param handler A method that takes a data and context and returns a value.\n */\nfunction onCall(handler) {\n    return _onCallWithOptions(handler, {});\n}\nexports.onCall = onCall;\n/** @hidden */\nfunction _onRequestWithOptions(handler, options) {\n    // lets us add __trigger without altering handler:\n    const cloudFunction = (req, res) => {\n        return handler(req, res);\n    };\n    cloudFunction.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n        httpsTrigger: {},\n    });\n    // TODO parse the options\n    return cloudFunction;\n}\nexports._onRequestWithOptions = _onRequestWithOptions;\n/**\n * Standard error codes and HTTP statuses for different ways a request can fail,\n * as defined by:\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n *\n * This map is used primarily to convert from a client error code string to\n * to the HTTP format error code string and status, and make sure it's in the\n * supported set.\n */\nconst errorCodeMap = {\n    ok: { canonicalName: 'OK', status: 200 },\n    cancelled: { canonicalName: 'CANCELLED', status: 499 },\n    unknown: { canonicalName: 'UNKNOWN', status: 500 },\n    'invalid-argument': { canonicalName: 'INVALID_ARGUMENT', status: 400 },\n    'deadline-exceeded': { canonicalName: 'DEADLINE_EXCEEDED', status: 504 },\n    'not-found': { canonicalName: 'NOT_FOUND', status: 404 },\n    'already-exists': { canonicalName: 'ALREADY_EXISTS', status: 409 },\n    'permission-denied': { canonicalName: 'PERMISSION_DENIED', status: 403 },\n    unauthenticated: { canonicalName: 'UNAUTHENTICATED', status: 401 },\n    'resource-exhausted': { canonicalName: 'RESOURCE_EXHAUSTED', status: 429 },\n    'failed-precondition': { canonicalName: 'FAILED_PRECONDITION', status: 400 },\n    aborted: { canonicalName: 'ABORTED', status: 409 },\n    'out-of-range': { canonicalName: 'OUT_OF_RANGE', status: 400 },\n    unimplemented: { canonicalName: 'UNIMPLEMENTED', status: 501 },\n    internal: { canonicalName: 'INTERNAL', status: 500 },\n    unavailable: { canonicalName: 'UNAVAILABLE', status: 503 },\n    'data-loss': { canonicalName: 'DATA_LOSS', status: 500 },\n};\n/**\n * An explicit error that can be thrown from a handler to send an error to the\n * client that called the function.\n */\nclass HttpsError extends Error {\n    constructor(code, message, details) {\n        super(message);\n        // A sanity check for non-TypeScript consumers.\n        if (code in errorCodeMap === false) {\n            throw new Error(`Unknown error code: ${code}.`);\n        }\n        this.code = code;\n        this.details = details;\n        this.httpErrorCode = errorCodeMap[code];\n    }\n    /** @hidden */\n    toJSON() {\n        const { details, httpErrorCode: { canonicalName: status }, message, } = this;\n        return {\n            ...(details === undefined ? {} : { details }),\n            message,\n            status,\n        };\n    }\n}\nexports.HttpsError = HttpsError;\n/** @hidden */\n// Returns true if req is a properly formatted callable request.\nfunction isValidRequest(req) {\n    // The body must not be empty.\n    if (!req.body) {\n        logger_1.warn('Request is missing body.');\n        return false;\n    }\n    // Make sure it's a POST.\n    if (req.method !== 'POST') {\n        logger_1.warn('Request has invalid method.', req.method);\n        return false;\n    }\n    // Check that the Content-Type is JSON.\n    let contentType = (req.header('Content-Type') || '').toLowerCase();\n    // If it has a charset, just ignore it for now.\n    const semiColon = contentType.indexOf(';');\n    if (semiColon >= 0) {\n        contentType = contentType.substr(0, semiColon).trim();\n    }\n    if (contentType !== 'application/json') {\n        logger_1.warn('Request has incorrect Content-Type.', contentType);\n        return false;\n    }\n    // The body must have data.\n    if (_.isUndefined(req.body.data)) {\n        logger_1.warn('Request body is missing data.', req.body);\n        return false;\n    }\n    // TODO(klimt): Allow only whitelisted http headers.\n    // Verify that the body does not have any extra fields.\n    const extras = _.omit(req.body, 'data');\n    if (!_.isEmpty(extras)) {\n        logger_1.warn('Request body has extra fields.', extras);\n        return false;\n    }\n    return true;\n}\n/** @hidden */\nconst LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\n/** @hidden */\nconst UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\n/**\n * Encodes arbitrary data in our special format for JSON.\n * This is exposed only for testing.\n */\n/** @hidden */\nfunction encode(data) {\n    if (_.isNull(data) || _.isUndefined(data)) {\n        return null;\n    }\n    // Oddly, _.isFinite(new Number(x)) always returns false, so unwrap Numbers.\n    if (data instanceof Number) {\n        data = data.valueOf();\n    }\n    if (_.isFinite(data)) {\n        // Any number in JS is safe to put directly in JSON and parse as a double\n        // without any loss of precision.\n        return data;\n    }\n    if (_.isBoolean(data)) {\n        return data;\n    }\n    if (_.isString(data)) {\n        return data;\n    }\n    if (_.isArray(data)) {\n        return _.map(data, encode);\n    }\n    if (_.isObject(data)) {\n        // It's not safe to use _.forEach, because the object might be 'array-like'\n        // if it has a key called 'length'. Note that this intentionally overrides\n        // any toJSON method that an object may have.\n        return _.mapValues(data, encode);\n    }\n    // If we got this far, the data is not encodable.\n    logger_1.error('Data cannot be encoded in JSON.', data);\n    throw new Error('Data cannot be encoded in JSON: ' + data);\n}\nexports.encode = encode;\n/**\n * Decodes our special format for JSON into native types.\n * This is exposed only for testing.\n */\n/** @hidden */\nfunction decode(data) {\n    if (data === null) {\n        return data;\n    }\n    if (data['@type']) {\n        switch (data['@type']) {\n            case LONG_TYPE:\n            // Fall through and handle this the same as unsigned.\n            case UNSIGNED_LONG_TYPE: {\n                // Technically, this could work return a valid number for malformed\n                // data if there was a number followed by garbage. But it's just not\n                // worth all the extra code to detect that case.\n                const value = parseFloat(data.value);\n                if (_.isNaN(value)) {\n                    logger_1.error('Data cannot be decoded from JSON.', data);\n                    throw new Error('Data cannot be decoded from JSON: ' + data);\n                }\n                return value;\n            }\n            default: {\n                logger_1.error('Data cannot be decoded from JSON.', data);\n                throw new Error('Data cannot be decoded from JSON: ' + data);\n            }\n        }\n    }\n    if (_.isArray(data)) {\n        return _.map(data, decode);\n    }\n    if (_.isObject(data)) {\n        // It's not safe to use _.forEach, because the object might be 'array-like'\n        // if it has a key called 'length'.\n        return _.mapValues(data, decode);\n    }\n    // Anything else is safe to return.\n    return data;\n}\nexports.decode = decode;\n/**\n * Check and verify tokens included in the requests. Once verified, tokens\n * are injected into the callable context.\n *\n * @param {Request} req - Request sent to the Callable function.\n * @param {CallableContext} ctx - Context to be sent to callable function handler.\n * @return {CallableTokenStatus} Status of the token verifications.\n */\n/** @hidden */\nasync function checkTokens(req, ctx) {\n    const verifications = {\n        app: 'MISSING',\n        auth: 'MISSING',\n    };\n    const appCheck = req.header('X-Firebase-AppCheck');\n    if (appCheck) {\n        verifications.app = 'INVALID';\n        try {\n            if (!apps_1.apps().admin.appCheck) {\n                throw new Error('Cannot validate AppCheck token. Please update Firebase Admin SDK to >= v9.8.0');\n            }\n            const appCheckToken = await apps_1.apps()\n                .admin.appCheck()\n                .verifyToken(appCheck);\n            ctx.app = {\n                appId: appCheckToken.appId,\n                token: appCheckToken.token,\n            };\n            verifications.app = 'VALID';\n        }\n        catch (err) {\n            logger_1.warn('Failed to validate AppCheck token.', err);\n        }\n    }\n    const authorization = req.header('Authorization');\n    if (authorization) {\n        verifications.auth = 'INVALID';\n        const match = authorization.match(/^Bearer (.*)$/);\n        if (match) {\n            const idToken = match[1];\n            try {\n                const authToken = await apps_1.apps()\n                    .admin.auth()\n                    .verifyIdToken(idToken);\n                verifications.auth = 'VALID';\n                ctx.auth = {\n                    uid: authToken.uid,\n                    token: authToken,\n                };\n            }\n            catch (err) {\n                logger_1.warn('Failed to validate auth token.', err);\n            }\n        }\n    }\n    const logPayload = {\n        verifications,\n        'logging.googleapis.com/labels': {\n            'firebase-log-type': 'callable-request-verification',\n        },\n    };\n    const errs = [];\n    if (verifications.app === 'INVALID') {\n        errs.push('AppCheck token was rejected.');\n    }\n    if (verifications.auth === 'INVALID') {\n        errs.push('Auth token was rejected.');\n    }\n    if (errs.length == 0) {\n        logger_1.info('Callable request verification passed', logPayload);\n    }\n    else {\n        logger_1.warn(`Callable request verification failed: ${errs.join(' ')}`, logPayload);\n    }\n    return verifications;\n}\n/** @hidden */\nconst corsHandler = cors({ origin: true, methods: 'POST' });\n/** @hidden */\nfunction _onCallWithOptions(handler, options) {\n    const func = async (req, res) => {\n        try {\n            if (!isValidRequest(req)) {\n                logger_1.error('Invalid request, unable to process.');\n                throw new HttpsError('invalid-argument', 'Bad Request');\n            }\n            const context = { rawRequest: req };\n            const tokenStatus = await checkTokens(req, context);\n            if (tokenStatus.app === 'INVALID' || tokenStatus.auth === 'INVALID') {\n                throw new HttpsError('unauthenticated', 'Unauthenticated');\n            }\n            const instanceId = req.header('Firebase-Instance-ID-Token');\n            if (instanceId) {\n                // Validating the token requires an http request, so we don't do it.\n                // If the user wants to use it for something, it will be validated then.\n                // Currently, the only real use case for this token is for sending\n                // pushes with FCM. In that case, the FCM APIs will validate the token.\n                context.instanceIdToken = req.header('Firebase-Instance-ID-Token');\n            }\n            const data = decode(req.body.data);\n            let result = await handler(data, context);\n            // Encode the result as JSON to preserve types like Dates.\n            result = encode(result);\n            // If there was some result, encode it in the body.\n            const responseBody = { result };\n            res.status(200).send(responseBody);\n        }\n        catch (err) {\n            if (!(err instanceof HttpsError)) {\n                // This doesn't count as an 'explicit' error.\n                logger_1.error('Unhandled error', err);\n                err = new HttpsError('internal', 'INTERNAL');\n            }\n            const { status } = err.httpErrorCode;\n            const body = { error: err.toJSON() };\n            res.status(status).send(body);\n        }\n    };\n    // Wrap the function with a cors handler.\n    const corsFunc = (req, res) => {\n        return corsHandler(req, res, () => func(req, res));\n    };\n    corsFunc.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n        httpsTrigger: {},\n        labels: { 'deployment-callable': 'true' },\n    });\n    corsFunc.run = handler;\n    return corsFunc;\n}\nexports._onCallWithOptions = _onCallWithOptions;\n"]},"metadata":{},"sourceType":"script"}